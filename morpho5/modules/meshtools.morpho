// Mesh creation and visualization tools

import constants

/** Creates a mesh from a parametric function.
 * @param[in] f - a function that returns the vertex position as a list
 * @param[in] range - parameter range to use
 * @param[in] closed - whether to close the mesh  */
fn LineMesh(f, range, closed=false) {
  var list = []

  for (t in range) list.append(f(t))

  var vertices = Matrix(list).transpose()
  var mesh = Mesh()
  mesh.setvertexmatrix(vertices)

  var np = range.count() // How many points
  var nlines = np-1

  var conn = Sparse(np,nlines)
  for (i in 0...nlines) {
    conn[i,i]=1
    conn[i+1,i]=1
  }
  if (closed) {
    conn[0,nlines]=1
    conn[np-1,nlines]=1
  }

  mesh.addgrade(1, conn)

  return mesh
}

/** Creates a mesh from a parametric function.
 * @param[in] f - a function that returns the vertex position as a list
 * @param[in] range - parameter range to use
 * @param[in] range - parameter range to use
 * @param[in] closed - whether to close the mesh  */
fn AreaMesh(f, r1, r2, closed=false) {
  var list = []

  for (v in r2) for (u in r1) list.append(f(u, v))
  var vertices = Matrix(list).transpose()

  var mesh = Mesh()
  mesh.setvertexmatrix(vertices)

  var nu = r1.count(), nv = r2.count() // How many points
  var np = nu*nv
  var nfaces = (nu-1)*(nv-1)

  var conn = Sparse(np,1)
  var nt = 0
  for (j in 0...nv-1) {
    for (i in 0...nu-1) {
      conn[i+j*nu, nt]=1; conn[i+1+j*nu, nt]=1; conn[i+nu+j*nu, nt]=1
      nt+=1
      conn[i+1+j*nu, nt]=1; conn[i+nu+j*nu, nt]=1; conn[i+1+nu+j*nu, nt]=1
      nt+=1
    }
  }

  // Close boundaries if selected
  var cu = closed, cv = closed
  if (islist(closed)) { cu=closed[0]; cv=closed[1] }

  if (cu) {
    var n=nu-1 // Connect right column to left column
    for (j in 0...nv-1) {
      conn[n+j*nu, nt]=1; conn[n+1+j*nu, nt]=1; conn[0+j*nu, nt]=1
      nt+=1
      conn[n+j*nu, nt]=1; conn[0+nu+j*nu, nt]=1; conn[n+nu+j*nu, nt]=1
      nt+=1
    }
  }
  if (cv) {
    var n=nv-1 // Connect top row to bottom row
    for (i in 0...nu-1) {
      conn[i+n*nu, nt]=1; conn[i+1+n*nu, nt]=1; conn[i, nt]=1
      nt+=1
      conn[i+1+n*nu, nt]=1; conn[i, nt]=1; conn[i+1, nt]=1
      nt+=1
    }
  }
  if (cu && cv) {  // For toroidal geometry, connect top right to bottom left
    conn[nu*nv-1, nt]=1; conn[(nv-1)*nu, nt]=1; conn[nu-1, nt]=1
    nt+=1
    conn[0, nt]=1; conn[(nv-1)*nu, nt]=1; conn[nu-1, nt]=1
    nt+=1
  }

  mesh.addgrade(2, conn)

  return mesh
}

/** Creates a mesh from a polyhedron specified as
  @param[in] list - a list of vertices
  @param[in] faces - list of lists of vertices corresponding to each face
  @returns a mesh */
fn PolyhedronMesh(list, faces) {
  var v = Matrix(list).transpose()
  var nv=list.count() // Number of vertices in polyhedron
  var nmp=faces.count() // Number of faces
  var nt=0
  var midpoints = []

  /* Find midpoints of the faces */
  for (f in faces) {
    var pt = Matrix(3)
    for (i in f) pt.acc(1, v.column(i))
    midpoints.append(pt/f.count())
    nt+=f.count()
  }

  var mesh = Mesh()

  /* Create the vertex matrix */
  var vertices = Matrix(3, list.count()+midpoints.count())
  for (i in 0...nv) vertices.setcolumn(i, Matrix(list[i]))
  for (i in 0...nmp) vertices.setcolumn(nv+i, midpoints[i])
  mesh.setvertexmatrix(vertices)

  /* Create the connectivity matrix */
  var conn = Sparse(nv+nmp,nt)
  var t=0
  for (k in 0...faces.count()) { // Loop over faces
    var face = faces[k]
    var fv = face.count()
    for (i in 0...fv) { // Loop over the vertex indices and create a triangle for every pair
      conn[face[i],t]=1
      if (i<fv-1) conn[face[i+1],t]=1 else conn[face[0],t]=1
      conn[k+nv,t]=1
      t+=1
    }
  }
  mesh.addgrade(2, conn)

  return mesh
}

/* ********************************
 * Refinement
 ******************************** */

// Calculate the midpoint of an edge
fn midpoint(vertices, edges, i) {
  var edge = edges.rowindices(i)
  return 0.5*(vertices.column(edge[0])+vertices.column(edge[1]))
}

// Swaps elements of an indexable object
fn swap(e, i, j) {
  var swp = e[i]; e[i] = e[j]; e[j]=swp
}

/** Refines a mesh */
fn refinemesh(m) {
  var vertices = m.vertexmatrix()
  var edges = m.connectivitymatrix(0, 1)
  if (isnil(edges)) { // If no edges are present, we should try to add them
    m.addgrade(1)
    edges = m.connectivitymatrix(0, 1)
    if (isnil(edges)) { print "Failed to add edges"; return }
  }
  var faces = m.connectivitymatrix(0, 2)

  // Identify number of vertices, edges and faces in the old mesh
  var dim = vertices.dimensions()[0]
  var nv = vertices.dimensions()[1]
  var nl = edges.dimensions()[1]
  var nf = faces.dimensions()[1]

  var new = Mesh()

  // Each refined edge contributes a new vertex
  var newvertices = Matrix(dim, nv+nl)
  for (i in 0...nv) newvertices.setcolumn(i, vertices.column(i))
  for (i in 0...nl) {
    newvertices.setcolumn(nv+i, midpoint(vertices, edges, i))
  }
  new.setvertexmatrix(newvertices)

  // Each edge becomes two edges
  var newedges = Sparse(nv+nl, nl) // Size is automatically updated
  var iedge = nl
  for (i in 0...nl) {
    var edge = edges.rowindices(i)
    newedges[edge[0], i]=1   // ] Edge 0
    newedges[nv+i, i]=1      // ]

    newedges[nv+i, iedge]=1     // ] Edge 1
    newedges[edge[1], iedge]=1  // ]
    iedge+=1
  }

  // Refine faces if present. Creates a canonical order for the face
  /*         a (e0[0])
           /   \
    e0   x ---  y  e1
        /  \ /  \
e0[1] b --- z -- c
            e2
  */
  var newfaces = Sparse(nv+nl, 4*nf)
  var iface = nf // Count over new triangles
  if (!isnil(faces)) {
    var faceedge = m.connectivitymatrix(1,2)

    for (i in 0...nf) {
      var fvert = faces.rowindices(i) // Vertices in this face
      var fedge = faceedge.rowindices(i) // Edges in this face

      var evert[3] // Vertices for each edge
      for (f, i in fedge) evert[i]=edges.rowindices(f)
      // evert 0 defines vertices a and b
      var va=evert[0][0], vb=evert[0][1], vc=evert[1][0]
      if (evert[0].ismember(vc)) vc = evert[1][1]
      // The vertices are now in canonical order

      // does edge 1 connect with a? if not swap
      if (!evert[1].ismember(va)) swap(fedge, 1, 2)
      // The edges are now in a canonical order, so that evert[1] connects to the first element of evert[0]
      var vx = nv+fedge[0], vy = nv+fedge[1], vz = nv+fedge[2]

      // Triangle a-x-y
      newfaces[va,i]=1; newfaces[vx,i]=1; newfaces[vy,i]=1
      // Triangle b-x-z
      newfaces[vb,iface]=1; newfaces[vx,iface]=1; newfaces[vz,iface]=1; iface+=1
      // Triangle c-y-z
      newfaces[vc,iface]=1; newfaces[vy,iface]=1; newfaces[vz,iface]=1; iface+=1
      // Triangle x-y-z
      newfaces[vx,iface]=1; newfaces[vy,iface]=1; newfaces[vz,iface]=1; iface+=1

      // Edge x-y
      newedges[vx, iedge]=1; newedges[vy, iedge]=1; iedge+=1
      // Edge x-z
      newedges[vx, iedge]=1; newedges[vz, iedge]=1; iedge+=1
      // Edge y-z
      newedges[vy, iedge]=1; newedges[vz, iedge]=1; iedge+=1
    }
  }

  new.addgrade(1, newedges)
  new.addgrade(2, newfaces)

  return new
}

/* Tests whether to flip an edge
   @param[in] v - vertex matrix of edge
   @param[in] ev - vertex indices of the edge
   @param[in] cv - vertex indices of the vertices in the two triangles not
                   present in the edge
   @returns true if the edge should be flipped */
fn equiangulatetest (v, ev, cv) {
  var a = (v.column(ev[0])-v.column(ev[1])).norm(), // Length of common edge
      b = (v.column(ev[0])-v.column(cv[0])).norm(), // Edges of face 1
      c = (v.column(ev[1])-v.column(cv[0])).norm(),
      d = (v.column(ev[0])-v.column(cv[1])).norm(), // Edges of face 2
      e = (v.column(ev[1])-v.column(cv[1])).norm()

   return ((b*b + c*c - a*a)*d*e + (d*d + e*e - a*a)*b*c) < 0
}

/* Finds vertices in a pair of triangles not in a common edge
   @param[in] ev - list of two vertex ids
   @param[in] faces - faces definition matrix
   @param[in] ef - ids of two adjacent faces
   @returns a list of vertices present in triangles ef but not part of ev */
fn cvert(ev, faces, ef) {
  var cv = []
  for (i in 0..1) for (v in faces.rowindices(ef[i])) if (!ev.ismember(v)) cv.append(v)
  return cv
}

/* Flip the edge */
fn edgeflip(m, iedge, edges, faces, ev, cv, ef) {
  edges.setrowindices(iedge, cv)
  faces.setrowindices(ef[0], [ev[0], cv[0], cv[1]])
  faces.setrowindices(ef[1], [ev[1], cv[0], cv[1]])
  m.resetconnectivity()
}

fn equiangulate(m, quiet=false) {
  var vert = m.vertexmatrix()
  var edges = m.connectivitymatrix(0,1)
  var faces = m.connectivitymatrix(0,2)
  var edgetoface = m.connectivitymatrix(2,1)
  var ne = edges.dimensions()[1]
  var nflip = 0

  for (iedge in 0...ne) {
    var ev=edges.rowindices(iedge) // vertices for this edge
    var ef=edgetoface.rowindices(iedge) // faces attached to this edge
    if (ef.count()!=2) continue  // Only edges that are connected to two triangles
    var cv=cvert(ev, faces, ef)
    if (equiangulatetest(vert, ev, cv)) {
      edgeflip(m, iedge, edges, faces, ev, cv, ef)
      edgetoface = m.connectivitymatrix(2,1) // Recalculate connectivity
      nflip+=1
    }
  }

  if (!quiet) print "Equiangulate: ${nflip} edges flipped."

  return nil
}
