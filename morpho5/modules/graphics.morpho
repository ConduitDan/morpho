/* Graphics */

import constants
import meshtools

/* **************************************
 * Utility functions
 **************************************** */

/** Constructs a rotation matrix
  @param[in] theta - rotation angle
  @param[in] axis - axis to rotate about
  @returns the rotation matrix  */
fn rotation(theta, axis) {
  var x = axis[0], y=axis[1], z=axis[2]
  var ctheta = cos(theta), stheta = sin(theta), cc=1-ctheta

  return Matrix(
  [[x*x*cc+ctheta,   x*y*cc-z*stheta, x*z*cc+y*stheta],
   [x*y*cc+z*stheta, y*y*cc+ctheta,   y*z*cc-x*stheta],
   [z*x*cc-y*stheta, y*z*cc+x*stheta, z*z*cc+ctheta ]]
  )
}

/** Generates a vector normal to a given vector but of arbitrary orientation */
fn normalvector(vec) {
  var order = [abs(vec[0]), abs(vec[1]), abs(vec[2])].order()
  var out=vec.clone()
  out[order[0]]=0
  out[order[1]]=vec[order[2]]
  out[order[2]]=-vec[order[1]]
  return out
}

/** Generate a random name */
fn randomalphanumstring(n) {
  var alpha="abcdefghijklmnopqrstuvwxyz0123456789"
  var name=""
  for (i in 1..n) name+=alpha[int(random()*(alpha.count()-1))]
  return name
}

/* **************************************
 * Graphics primitives
 **************************************** */

/** TriangleComplexes are a basic graphical unit that draw a set of triangles
   from a given set of vertices. */
class TriangleComplex {
  init(position, normals, colors, connectivity) {
    self.position=position /* Vertex position matrix */
    self.normals=normals /* Matrix of normal vectors */
    self.colors=colors /* Color */
    self.connectivity=connectivity /* Connectivity matrix; columns are triangles */
  }

	/* Serialize the triangle complex to morphoview format */
  view(out) {
    var x = self.position
    var n = self.normals
    var col = self.colors
    var localcolor = false
    var dimensions=x.dimensions()
    var dim = dimensions[0]
    var nv = dimensions[1]

    if (ismatrix(col)) {
      if (col.dimensions()[1]>1) localcolor = true
    } else if (isobject(col) && !islist(col)) col = col.rgb(0)

    out.write("v \"xnc\"")
    for (i in 0...nv) {
      var line = ""
      for (j in 0...dim) {
        line+="${x[j,i]} "
      }
      for (j in 0...dim) {
        line+="${n[j,i]} "
      }
      if (localcolor) {
        for (j in 0...3) line+="${col[j,i]} "
      } else {
        for (j in 0...self.colors.count()) line+="${col[j]} "
      }
      out.write(line)
    }

    out.write("f")
    var f=self.connectivity
    nv=f.dimensions()[0]
    var nf=f.dimensions()[1]

    for (i in 0...nf) {
      var line = ""
      for (j in 0...nv) {
        if (f[j,i]!=0) line+="${j} "
      }
      out.write(line)
    }

  }
}

/* **************************************
 * Construct objects from primitives
 **************************************** */

/** Draws an arrow
  @param[in] start - start point
  @param[in] end - end point
  @param[in] aspectratio - aspect ratio of the arrow
  @param[in] n - number of faces to use
  @param[in] color - Color of the sphere
*/
fn Arrow(start, end, aspectratio=0.1, n=10, color=nil) {
  var col = color
  if (isnil(col)) col = [0.5,0.5,0.5]

  var np=3*n+2 // 2 points at the end plus 3*n point
  var nt=6*n
  var dim=start.count()
  var vertices=Matrix(dim, np)
  var normals=Matrix(dim, np)

  var x1=Matrix(start), x2=Matrix(end)
  var dx=x2-x1 // Vector from x1 to x2
  var length = dx.norm()
  var ndx=dx/length

  var px=normalvector(dx)
  var pxnorm=px.norm()
  if (abs(pxnorm)<1e-15) return
  px=0.5*length*aspectratio*px/pxnorm

  // Head and base of the arrow
  vertices.setcolumn(0, x1)
  vertices.setcolumn(np-1, x2)
  normals.setcolumn(0, -1*dx)
  normals.setcolumn(np-1, dx)

  /* The arrow is structured like so:

         [n+1...2n]   C--[2n+1...3n]
                    \ |\
  [1..n] A------------B \
         |               \
         0<----- u --->   1 3n+1
         <------ dx ------> */
  var u=(1-aspectratio)*dx
  for (i in 1..n) {
      var theta = 2*Pi*(i-1)/n
      var qx = rotation(theta, ndx)*px
      var nn=qx/qx.norm()
      var pt = qx+x1
      // Find vertex ring A by rotating px about ndx, to obtain qx, and then adding x1
      vertices.setcolumn(i, pt)
      // Vertex ring B is obtained by simply translating the first circle by dx*(1-ar)
      vertices.setcolumn(n+i, pt+u)
      // Vertex ring C is obtained by simply adding qx to the point in vertex ring B
      vertices.setcolumn(2*n+i, pt+u+qx)

      // Normals
      normals.setcolumn(i, nn)
      normals.setcolumn(n+i, nn)
      normals.setcolumn(2*n+i, nn)
  }

  var conn=Sparse(np,nt)
  for (i in 0...n) {
    // Layer 0-A
    conn[0,i]=1
    conn[i+1,i]=1
    if (i<n-1) conn[i+2,i]=1 else conn[1,i]=1

    // C-1
    conn[np-1,n+i]=1
    conn[2*n+i+1,n+i]=1
    if (i<n-1) conn[2*n+i+2,n+i]=1 else conn[2*n+1,n+i]=1

    // Layer A-B
    conn[i+1,2*n+i]=1
    conn[n+i+1,2*n+i]=1
    if (i<n-1) conn[i+2,2*n+i]=1 else conn[1,2*n+i]=1

    if (i<n-1) conn[i+2,3*n+i]=1 else conn[1,3*n+i]=1
    if (i<n-1) conn[n+i+2,3*n+i]=1 else conn[n+1,3*n+i]=1
    conn[n+i+1,3*n+i]=1

    // Layer B-C
    conn[n+i+1,4*n+i]=1
    if (i<n-1) conn[n+i+2,4*n+i]=1 else conn[n+1,4*n+i]=1
    conn[2*n+i+1,4*n+i]=1

    if (i<n-1) conn[n+i+2,5*n+i]=1 else conn[n+1,5*n+i]=1
    if (i<n-1) conn[2*n+i+2,5*n+i]=1 else conn[2*n+1,5*n+i]=1
    conn[2*n+i+1,5*n+i]=1
  }

  return TriangleComplex(vertices, normals, col, conn)
}

/** Draws a cylinder
  @param[in] start - start point
  @param[in] end - end point
  @param[in] aspectratio - aspect ratio
  @param[in] n - number of faces to use
  @param[in] color - Color of the sphere
*/
fn Cylinder(start, end, aspectratio=0.1, n=10, color=nil) {
  var col = color
  if (isnil(col)) col = [0.5,0.5,0.5]

  var np=2*n+2 // 2 points at the end plus 2*n point
  var nt=4*n
  var dim=start.count()
  var vertices=Matrix(dim, np);
  var normals=Matrix(dim, np);

  var x1=Matrix(start), x2=Matrix(end)
  var dx=x2-x1 // Vector from x1 to x2
  var length = dx.norm()
  if (abs(length)<1e-8) return nil
  var ndx=dx/length

  var px=normalvector(dx)
  var pxnorm=px.norm()
  if (abs(pxnorm)<1e-15) return
  px=0.5*length*aspectratio*px/pxnorm

  // Head and base of the arrow
  vertices.setcolumn(0, x1)
  vertices.setcolumn(np-1, x2)
  normals.setcolumn(0, -1*dx)
  normals.setcolumn(np-1, dx)

  /* The cylinder is structured like so:

         [n+1...2n]
                    \
  [1..n] A------------B
         |            |
         0            1 2n+1
         <---- dx ----> */
  for (i in 1..n) {
      var theta = 2*Pi*(i-1)/n
      var qx = rotation(theta, ndx)*px
      var nn=qx/qx.norm()
      var pt = qx+x1
      // Find vertex ring A by rotating px about ndx, to obtain qx, and then adding x1
      vertices.setcolumn(i, pt)
      // Vertex ring B is obtained by simply translating the first circle by dx*(1-ar)
      vertices.setcolumn(n+i, pt+dx)

      // Normals
      normals.setcolumn(i, nn)
      normals.setcolumn(n+i, nn)
  }

  var conn=Sparse(np,nt)
  for (i in 0...n) {
    // Layer 0-A
    conn[0,i]=1
    conn[i+1,i]=1
    if (i<n-1) conn[i+2,i]=1 else conn[1,i]=1

    // C-1
    conn[np-1,n+i]=1
    conn[n+i+1,n+i]=1
    if (i<n-1) conn[n+i+2,n+i]=1 else conn[n+1,n+i]=1

    // Layer A-B
    conn[i+1,2*n+i]=1
    conn[n+i+1,2*n+i]=1
    if (i<n-1) conn[i+2,2*n+i]=1 else conn[1,2*n+i]=1

    if (i<n-1) conn[i+2,3*n+i]=1 else conn[1,3*n+i]=1
    if (i<n-1) conn[n+i+2,3*n+i]=1 else conn[n+1,3*n+i]=1
    conn[n+i+1,3*n+i]=1
  }

  return TriangleComplex(vertices, normals, col, conn)
}

/** Draws a tube
  @param[in] pts - list of points or a matrix with points as the columns
  @param[in] rad - radius
  @param[in] n - number of faces to use per point
  @param[in] closed - whether to treat the point list as closed or not
  @param[in] color - Color of the sphere
*/
fn Tube(pts, rad, n=10, color=nil, closed=false) {
  fn normalvector(vec) { // Musn't take the abs for Tube
    var order = [vec[0], vec[1], vec[2]].order()
    var out=vec.clone()
    out[order[0]]=0
    out[order[1]]=vec[order[2]]
    out[order[2]]=-vec[order[1]]
    return out
  }

  var col = color
  if (isnil(col)) col = [0.5,0.5,0.5]

  var mat = pts
  if (islist(pts)) mat = Matrix(pts).transpose();

  var np=mat.dimensions()[1]
	var dim=mat.dimensions()[0]
  var nv=n*np
	var nt=n*(2*(np-1))
  if (!closed) {
		nv+=2 // Two points for the caps
		nt+=2*n // n triangles for each cap
	}

  var vertices=Matrix(dim, nv);
  var normals=Matrix(dim, nv);

	var sep[np], ndx[np]

	// Loop over line segments to calculate separation vectors
	for (k in 0..np-2) {
		var dx=mat.column(k+1)-mat.column(k)
		sep[k]=dx/dx.norm()
		ndx[k]+=sep[k]
		ndx[k+1]+=sep[k]
	}

	// Correct ends if closed
	if (closed) {
		var dx=mat.column(0)-mat.column(np-1)
		sep[np-1]=dx/dx.norm()
		ndx[np-1]+=sep[np-1]
		ndx[0]+=sep[np-1]
	}

	// Now generate vertices
 	for (k in 0...np) {
		var px // Vertices are generated from a point plus this displacement
 		if (k==0) {
			px=normalvector(ndx[k])
		} else { // This aligns vertices generated from successive points
			var dx=vertices.column((k-1)*n)-mat.column(k-1)
			px=dx-dx.inner(ndx[k])*ndx[k]/ndx[k].norm()
		}
		px=rad*px/px.norm()

		var x1 = mat.column(k)
		for (i in 0...n) {
			/* Find vertex ring at point k by rotating px about ndx, to obtain qx, and then adding x1 */
      var theta = i*2*Pi/n
			var qx = rotation(theta, ndx[k])*px
			vertices.setcolumn(k*n+i, x1+qx)

			normals.setcolumn(k*n+i, qx/qx.norm())
		}
 	}

	/* Loop over segments again to create the triangles */
	var conn=Sparse(nv,nt)

	var m=0
	for (k in 0..np-2) {
		for (i in 0...n) {
			conn[k*n+i,m]=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			conn[((k+1)*n+i),m]=1
			m+=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			if (i==n-1) conn[(k+1)*n,m]=1 else conn[((k+1)*n+i)+1,m]=1
			conn[((k+1)*n+i),m]=1
			m+=1
		}
	}

	if (closed) {
		// Connect first and last points
		var k=np-1
		for (i in 0...n) {
			conn[k*n+i,m]=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			conn[i,m]=1
			m+=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			if (i==n-1) conn[0,m]=1 else conn[i+1,m]=1
			conn[i,m]=1
			m+=1
		}
	} else {
		// End caps
		vertices.setcolumn(nv-2, mat.column(0))
		vertices.setcolumn(nv-1, mat.column(np-1))

		normals.setcolumn(nv-2, -sep[0]/sep[0].norm())
		normals.setcolumn(nv-1, sep[np-2]/sep[np-2].norm())

		for (i in 0...n) {
			conn[i,m]=1
			if (i==n-1) conn[0,m]=1 else conn[i+1,m]=1
			conn[nv-2,m]=1
			m+=1
			conn[((np-1)*n+i),m]=1
			if (i==n-1) conn[(np-1)*n,m]=1 else conn[((np-1)*n+i)+1,m]=1
			conn[nv-1,m]=1
			m+=1
		}
	}

  return TriangleComplex(vertices, normals, col, conn)
}

var sphere = [ PolyhedronMesh(
  [[-0.982247, 0.0, 0.187592], [0.982247,
    0.0, -0.187592], [-0.303531, -0.934172, 0.187592], [-0.303531,
    0.934172, 0.187592], [0.794654, -0.57735, 0.187592], [0.794654,
    0.57735, 0.187592], [-0.187592, -0.57735, 0.794654], [-0.187592,
    0.57735, 0.794654], [-0.491123, -0.356822, -0.794654], [-0.491123,
    0.356822, -0.794654], [0.491123, -0.356822, 0.794654], [0.491123,
    0.356822, 0.794654], [0.607062,
    0.0, -0.794654], [-0.794654, -0.57735, -0.187592], [-0.794654,
    0.57735, -0.187592], [-0.607062, 0.0,
    0.794654], [0.187592, -0.57735, -0.794654], [0.187592,
    0.57735, -0.794654], [0.303531, -0.934172, -0.187592], [0.303531,
    0.934172, -0.187592]]
  ,
  [[14, 9, 8, 13, 0], [1, 5, 11, 10, 4], [4, 10, 6, 2, 18], [10, 11, 7,
    15, 6], [11, 5, 19, 3, 7], [5, 1, 12, 17, 19], [1, 4, 18, 16,
    12], [3, 19, 17, 9, 14], [17, 12, 16, 8, 9], [16, 18, 2, 13, 8], [2,
     6, 15, 0, 13], [15, 7, 3, 14, 0]]
) ]

/** Draws a sphere
  @param[in] center - the center of the sphere
  @param[in] r - radius
  @param[in] color - Color of the sphere
*/
fn Sphere(center, r, color=nil, maxrefine = 3) {
  var col = color
  if (isnil(col)) col = [0.5,0.5,0.5]
  var n = 0

  // Find the necessary refined sphere
  while (r/(2^n)>=0.1 && n<maxrefine) {
    if (n>=sphere.count()-1) {
      sphere.append(refinemesh(sphere[-1]))
    }
    n += 1;
  }

  var v = sphere[n].vertexmatrix().clone()
  var normals = sphere[n].vertexmatrix().clone()
  var conn = sphere[n].connectivitymatrix(0,2) // Should clone!
  var nv = v.dimensions()[1]

  var x0=center
  if (islist(center)) x0=Matrix(center)

  for (i in 0...nv) { // Normalize, scale and translate
    var x = v.column(i)
    var nn = x/x.norm()
    normals.setcolumn(i, nn)
    v.setcolumn(i, x0 + r*nn)
  }

  return TriangleComplex(v, normals, col, conn)
}

/* **************************************
 * Graphics class
 **************************************** */

class Graphics {
  init() {
    self.displaylist = [] // A collection of primitives to display
    self.title = "Morpho" // Title to show
  }

  display(item) {
    if (isobject(item)) self.displaylist.append(item)
  }

  view(out) {
    // Define the objects
    for (i in 0...self.displaylist.count()) {
      out.write("o ${i}")
      self.displaylist[i].view(out)
    }
    // Draw the objects
    for (i in 0...self.displaylist.count()) {
      out.write("i")
      out.write("d ${i}")
    }
  }

  add(right) { // Create a union of two graphics objects
    var g = Graphics()
    for (el in self.displaylist) g.displaylist.append(el)
    for (el in right.displaylist) g.displaylist.append(el)
    return g
  }
}

/* **************************************
 * Show a graphics object
 **************************************** */

class Show {
  init(g) {
    var tempfolder = "/tmp"
    var fname = randomalphanumstring(10)
    var out = File("${tempfolder}/morpho${fname}.draw", "w")

    out.write("S 1 3")
    out.write("W \"${g.title}\"")

    g.view(out)

    out.close()
    system("morphoview -t ${tempfolder}/morpho${fname}.draw &")
  }
}
