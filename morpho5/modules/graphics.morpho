/* Graphics */

import constants

/* **************************************
 * Utility functions
 **************************************** */

/** Constructs a rotation matrix
  @param[in] theta - rotation angle
  @param[in] axis - axis to rotate about
  @returns the rotation matrix  */
fn rotation(theta, axis) {
  var x = axis[0], y=axis[1], z=axis[2]
  var ctheta = cos(theta), stheta = sin(theta), cc=1-ctheta

  return Matrix(
  [[x*x*cc+ctheta,   x*y*cc-z*stheta, x*z*cc+y*stheta],
   [x*y*cc+z*stheta, y*y*cc+ctheta,   y*z*cc-x*stheta],
   [z*x*cc-y*stheta, y*z*cc+x*stheta, z*z*cc+ctheta ]]
  )
}

/** Generates a vector nornal to a given vector but of arbitrary orientation */
fn normalvector(vec) {
  var order = [abs(vec[0]), abs(vec[1]), abs(vec[2])].order()
  var out=vec.clone()
  out[order[0]]=0
  out[order[1]]=vec[order[2]]
  out[order[2]]=-vec[order[1]]
  return out
}

/** Generate a random name */
fn randomalphanumstring(n) {
  var alpha="abcdefghijklmnopqrstuvwxyz0123456789"
  var name=""
  for (i in 1..n) name+=alpha[int(random()*(alpha.count()-1))]
  return name
}

/* **************************************
 * Graphics primitives
 **************************************** */

/** TriangleComplexes are a basic graphical unit that draw a set of triangles
   from a given set of vertices. */
class TriangleComplex {
  init(position, normals, colors, connectivity) {
    self.position=position /* Vertex position matrix */
    self.normals=normals /* Matrix of normal vectors */
    self.colors=colors /* Color */
    self.connectivity=connectivity /* Connectivity matrix; columns are triangles */
  }

	/* Serialize the triangle complex to morphoview format */
  view(out) {
    var x = self.position
    var n = self.normals
    var col = self.colors
    var dimensions=x.dimensions()
    var dim = dimensions[0]
    var nv = dimensions[1]

    out.write("v \"xnc\"")
    for (i in 0...nv) {
      var line = ""
      for (j in 0...dim) {
        line+="${x[j,i]} "
      }
      for (j in 0...dim) {
        line+="${n[j,i]} "
      }
      for (j in 0...self.colors.count()) {
        line+="${col[j]} "
      }
      out.write(line)
    }

    out.write("f")
    var f=self.connectivity
    nv=f.dimensions()[0]
    var nf=f.dimensions()[1]

    for (i in 0...nf) {
      var line = ""
      for (j in 0...nv) {
        if (f[j,i]!=0) line+="${j} "
      }
      out.write(line)
    }

  }
}

/* **************************************
 * Construct objects from primitives
 **************************************** */

/** Draws an arrow
  @param[in] start - start point
  @param[in] end - end point
  @param[in] n - number of faces to use
*/
fn arrow(start, end, ar, n) {
  var np=3*n+2 // 2 points at the end plus 3*n point
  var nt=6*n
  var dim=start.count()
  var vertices=Matrix(dim, np);
  var normals=Matrix(dim, np);

  var x1=Matrix(start), x2=Matrix(end)
  var dx=x2-x1 // Vector from x1 to x2
  var length = dx.norm()
  var ndx=dx/length

  var px=normalvector(dx)
  var pxnorm=px.norm()
  if (abs(pxnorm)<1e-15) return
  px=0.5*length*ar*px/pxnorm

  // Head and base of the arrow
  vertices.setcolumn(0, x1)
  vertices.setcolumn(np-1, x2)
  normals.setcolumn(0, -1*dx)
  normals.setcolumn(np-1, dx)

  /* The arrow is structured like so:

         [n+1...2n]   C--[2n+1...3n]
                    \ |\
  [1..n] A------------B \
         |               \
         0<----- u --->   1 3n+1
         <------ dx ------> */
  var u=(1-ar)*dx
  for (i in 1..n) {
      var theta = 2*Pi*(i-1)/n
      var qx = rotation(theta, ndx)*px
      var nn=qx/qx.norm()
      var pt = qx+x1
      // Find vertex ring A by rotating px about ndx, to obtain qx, and then adding x1
      vertices.setcolumn(i, pt)
      // Vertex ring B is obtained by simply translating the first circle by dx*(1-ar)
      vertices.setcolumn(n+i, pt+u)
      // Vertex ring C is obtained by simply adding qx to the point in vertex ring B
      vertices.setcolumn(2*n+i, pt+u+qx)

      // Normals
      normals.setcolumn(i, nn)
      normals.setcolumn(n+i, nn)
      normals.setcolumn(2*n+i, nn)
  }

  var conn=Sparse(np,nt)
  for (i in 0...n) {
    // Layer 0-A
    conn[0,i]=1
    conn[i+1,i]=1
    if (i<n-1) conn[i+2,i]=1 else conn[1,i]=1

    // C-1
    conn[np-1,n+i]=1
    conn[2*n+i+1,n+i]=1
    if (i<n-1) conn[2*n+i+2,n+i]=1 else conn[2*n+1,n+i]=1

    // Layer A-B
    conn[i+1,2*n+i]=1
    conn[n+i+1,2*n+i]=1
    if (i<n-1) conn[i+2,2*n+i]=1 else conn[1,2*n+i]=1

    if (i<n-1) conn[i+2,3*n+i]=1 else conn[1,3*n+i]=1
    if (i<n-1) conn[n+i+2,3*n+i]=1 else conn[n+1,3*n+i]=1
    conn[n+i+1,3*n+i]=1

    // Layer B-C
    conn[n+i+1,4*n+i]=1
    if (i<n-1) conn[n+i+2,4*n+i]=1 else conn[n+1,4*n+i]=1
    conn[2*n+i+1,4*n+i]=1

    if (i<n-1) conn[n+i+2,5*n+i]=1 else conn[n+1,5*n+i]=1
    if (i<n-1) conn[2*n+i+2,5*n+i]=1 else conn[2*n+1,5*n+i]=1
    conn[2*n+i+1,5*n+i]=1
  }

  return TriangleComplex(vertices, normals, [0.5,0.5,0.5], conn)
}

/** Draws a cylinder
  @param[in] start - start point
  @param[in] end - end point
  @param[in] n - number of faces to use
*/
fn cylinder(start, end, ar, n) {
  var np=2*n+2 // 2 points at the end plus 2*n point
  var nt=4*n
  var dim=start.count()
  var vertices=Matrix(dim, np);
  var normals=Matrix(dim, np);

  var x1=Matrix(start), x2=Matrix(end)
  var dx=x2-x1 // Vector from x1 to x2
  var length = dx.norm()
  if (abs(length)<1e-8) return nil
  var ndx=dx/length

  var px=normalvector(dx)
  var pxnorm=px.norm()
  if (abs(pxnorm)<1e-15) return
  px=0.5*length*ar*px/pxnorm

  // Head and base of the arrow
  vertices.setcolumn(0, x1)
  vertices.setcolumn(np-1, x2)
  normals.setcolumn(0, -1*dx)
  normals.setcolumn(np-1, dx)

  /* The cylinder is structured like so:

         [n+1...2n]
                    \
  [1..n] A------------B
         |            |
         0            1 2n+1
         <---- dx ----> */
  for (i in 1..n) {
      var theta = 2*Pi*(i-1)/n
      var qx = rotation(theta, ndx)*px
      var nn=qx/qx.norm()
      var pt = qx+x1
      // Find vertex ring A by rotating px about ndx, to obtain qx, and then adding x1
      vertices.setcolumn(i, pt)
      // Vertex ring B is obtained by simply translating the first circle by dx*(1-ar)
      vertices.setcolumn(n+i, pt+dx)

      // Normals
      normals.setcolumn(i, nn)
      normals.setcolumn(n+i, nn)
  }

  var conn=Sparse(np,nt)
  for (i in 0...n) {
    // Layer 0-A
    conn[0,i]=1
    conn[i+1,i]=1
    if (i<n-1) conn[i+2,i]=1 else conn[1,i]=1

    // C-1
    conn[np-1,n+i]=1
    conn[n+i+1,n+i]=1
    if (i<n-1) conn[n+i+2,n+i]=1 else conn[n+1,n+i]=1

    // Layer A-B
    conn[i+1,2*n+i]=1
    conn[n+i+1,2*n+i]=1
    if (i<n-1) conn[i+2,2*n+i]=1 else conn[1,2*n+i]=1

    if (i<n-1) conn[i+2,3*n+i]=1 else conn[1,3*n+i]=1
    if (i<n-1) conn[n+i+2,3*n+i]=1 else conn[n+1,3*n+i]=1
    conn[n+i+1,3*n+i]=1
  }

  return TriangleComplex(vertices, normals, [0.5,0.5,0.5], conn)
}

/** Draws a tube
  @param[in] pts - list of points or a matrix with points as the columns
  @param[in] rad - radius
  @param[in] n - number of faces to use per point
  @param[in] closed - whether to treat the point list as closed or not
*/
fn tube(pts, rad, n, closed) {
  var mat = pts
  if (islist(pts)) mat = Matrix(pts).transpose();

  var np=mat.dimensions()[1]
	var dim=mat.dimensions()[0]
  var nv=n*np
	var nt=n*(2*(np-1))
  if (!closed) {
		nv+=2 // Two points for the caps
		nt+=2*n // n triangles for each cap
	}

  var vertices=Matrix(dim, nv);
  var normals=Matrix(dim, nv);

	var sep[np], ndx[np]

	// Loop over line segments to calculate separation vectors
	for (k in 0..np-2) {
		var dx=mat.column(k+1)-mat.column(k)
		sep[k]=dx/dx.norm()
		ndx[k]+=sep[k]
		ndx[k+1]+=sep[k]
	}

	// Correct ends if closed
	if (closed) {
		var dx=mat.column(0)-mat.column(np-1)
		sep[np-1]=dx/dx.norm()
		ndx[np-1]+=sep[np-1]
		ndx[0]+=sep[np-1]
	}

	// Now generate vertices
 	for (k in 0...np) {
		var px // Vertices are generated from a point plus this displacement
 		if (k==0) {
			px=normalvector(ndx[k])
		} else { // This aligns vertices generated from successive points
			var dx=vertices.column((k-1)*n)-mat.column(k-1)
			px=dx-dx.inner(ndx[k])*ndx[k]/ndx[k].norm()
		}
		px=rad*px/px.norm()

		var x1 = mat.column(k)
		for (i in 0...n) {
			/* Find vertex ring at point k by rotating px about ndx, to obtain qx, and then adding x1 */
      var theta = i*2*Pi/n
			var qx = rotation(theta, ndx[k])*px
			vertices.setcolumn(k*n+i, x1+qx)

			normals.setcolumn(k*n+i, qx/qx.norm())
		}
 	}

	/* Loop over segments again to create the triangles */
	var conn=Sparse(nv,nt)

	var m=0
	for (k in 0..np-2) {
		for (i in 0...n) {
			conn[k*n+i,m]=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			conn[((k+1)*n+i),m]=1
			m+=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			if (i==n-1) conn[(k+1)*n,m]=1 else conn[((k+1)*n+i)+1,m]=1
			conn[((k+1)*n+i),m]=1
			m+=1
		}
	}

	if (closed) {
		// Connect first and last points
		var k=np-1
		for (i in 0...n) {
			conn[k*n+i,m]=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			conn[i,m]=1
			m+=1
			if (i==n-1) conn[k*n,m]=1 else conn[k*n+i+1,m]=1
			if (i==n-1) conn[0,m]=1 else conn[i+1,m]=1
			conn[i,m]=1
			m+=1
		}
	} else {
		// End caps
		vertices.setcolumn(nv-2, mat.column(0))
		vertices.setcolumn(nv-1, mat.column(np-1))

		normals.setcolumn(nv-2, -sep[0]/sep[0].norm())
		normals.setcolumn(nv-1, sep[np-2]/sep[np-2].norm())

		for (i in 0...n) {
			conn[i,m]=1
			if (i==n-1) conn[0,m]=1 else conn[i+1,m]=1
			conn[nv-2,m]=1
			m+=1
			conn[((np-1)*n+i),m]=1
			if (i==n-1) conn[(np-1)*n,m]=1 else conn[((np-1)*n+i)+1,m]=1
			conn[nv-1,m]=1
			m+=1
		}
	}

  return TriangleComplex(vertices, normals, [0.5,0.5,0.5], conn)
}



/* **************************************
 * Graphics class
 **************************************** */

class Graphics {
  init(m) {
    self.displaylist = [] // A collection of primitives to display
    self.title = "Morpho" // Title to show
    if (ismesh(m)) self.drawmesh(m)
  }

  display(item) {
    if (isobject(item)) self.displaylist.append(item)
  }

  drawmesh(mesh) {
    var vertices = mesh.vertexmatrix()
    var f = mesh.connectivitymatrix(0,2)

    if (issparse(f)) {
      // Estimate the normal from the gradient of the area
      var a = Area()
      var normal=a.gradient(mesh)

      self.display(TriangleComplex(vertices, normal, [0.5, 0.5, 0.5], f))
    }
  }

  view(out) {
    // Define the objects
    for (i in 0...self.displaylist.count()) {
      out.write("o ${i}")
      self.displaylist[i].view(out)
    }
    // Draw the objects
    for (i in 0...self.displaylist.count()) {
      out.write("i")
      out.write("d ${i}")
    }
  }
}

/* **************************************
 * Show a graphics object
 **************************************** */

class Show {
  init(g) {
    var tempfolder = "/tmp"
    var fname = randomalphanumstring(10)
    var out = File("${tempfolder}/morpho${fname}.draw", "w")

    out.write("S 1 3")
    out.write("W \"${g.title}\"")

    g.view(out)

    out.close()
    system("morphoview ${tempfolder}/morpho${fname}.draw &")
  }
}
